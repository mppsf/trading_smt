 Требования по реализации SMT Trading Analyzer для Claude Sonnet 4

## 1. Подход к разработке с Claude Sonnet 4

### 1.1 Стратегия взаимодействия
- **Итеративная разработка**: Создание проекта блоками с тестированием каждого компонента
- **Четкие технические спецификации**: Детальное описание каждого модуля перед реализацией
- **Структурированный код**: Максимальная читаемость и документированность
- **Готовые к использованию артефакты**: Полностью функциональные компоненты без заглушек

### 1.2 Последовательность реализации

#### Этап 1: Backend Core Infrastructure (День 1-2)
1. **Project Structure Setup**
   - Docker compose конфигурация
   - Backend структура с FastAPI
   - Database models (SQLAlchemy)
   - Environment configuration

2. **Data Collection Service**
   - Yahoo Finance integration
   - Data validation and storage
   - Caching mechanism with Redis
   - Background tasks with Celery

#### Этап 2: SMT Analysis Engine (День 3-4)
1. **Core Trading Logic**
   - SMT divergence detection algorithms
   - Killzone time detection
   - Market structure analysis (MSS, CISD)
   - Order blocks and FVG identification

2. **Signal Processing**
   - Liquidity sweep detection
   - Signal confirmation logic
   - Risk/reward calculations
   - Historical pattern matching

#### Этап 3: LLM Integration (День 5-6)
1. **Claude Sonnet 4 Integration**
   - API client implementation
   - Prompt engineering for trading analysis
   - Response parsing and validation
   - Error handling and fallbacks

2. **Analysis Pipeline**
   - Data preprocessing for LLM
   - Structured response handling
   - Confidence scoring algorithms
   - Analysis caching and optimization

#### Этап 4: Frontend Dashboard (День 7-8)
1. **React Application**
   - TypeScript setup with modern tooling
   - Chart components for price visualization
   - Real-time data display
   - Responsive design

2. **Trading Interface**
   - SMT signal visualization
   - Killzone indicators
   - Analysis panel with LLM insights
   - Historical data browser

#### Этап 5: Integration & Testing (День 9-10)
1. **End-to-end Integration**
   - WebSocket real-time updates
   - API endpoint testing
   - Performance optimization
   - Error handling refinement

## 2. Технические спецификации для каждого модуля

### 2.1 Backend API Architecture

```python
# Основная структура FastAPI приложения
from fastapi import FastAPI, WebSocket, Depends, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session
import asyncio
from typing import List, Optional
from datetime import datetime, timezone

# Модели данных
from pydantic import BaseModel, validator
from enum import Enum

class KillzoneType(str, Enum):
    ASIA = "asia"
    LONDON = "london" 
    NY_AM = "ny_am"
    NY_LUNCH = "ny_lunch"
    NY_PM = "ny_pm"

class SMTSignalType(str, Enum):
    BULLISH_DIVERGENCE = "bullish_divergence"
    BEARISH_DIVERGENCE = "bearish_divergence"
    NEUTRAL = "neutral"

class MarketDataRequest(BaseModel):
    symbols: List[str] = ["QQQ", "SPY"]
    timeframe: str = "5m"
    limit: int = 100

class SMTAnalysisResponse(BaseModel):
    timestamp: datetime
    nasdaq_price: float
    sp500_price: float
    smt_signal: SMTSignalType
    confidence: float
    killzone: Optional[KillzoneType]
    analysis_text: str
    risk_score: int
    entry_levels: List[float]
    target_levels: List[float]
```

### 2.2 Data Collection Service Specification

```python
# Yahoo Finance Data Collector
import yfinance as yf
import pandas as pd
from datetime import datetime, timedelta
import asyncio
from typing import Dict, List
import redis
import json

class MarketDataCollector:
    def __init__(self):
        self.redis_client = redis.Redis(host='redis', port=6379, db=0)
        self.symbols = ["QQQ", "SPY"]
        self.timeframes = ["5m", "15m"]
    
    async def collect_realtime_data(self) -> Dict:
        """Сбор real-time данных с Yahoo Finance"""
        data = {}
        for symbol in self.symbols:
            ticker = yf.Ticker(symbol)
            # Получение данных за последние 2 дня с интервалом 5м
            hist = ticker.history(period="2d", interval="5m")
            # Текущая цена и объем
            info = ticker.info
            
            data[symbol] = {
                "current_price": hist['Close'].iloc[-1],
                "volume": hist['Volume'].iloc[-1],
                "change_percent": ((hist['Close'].iloc[-1] / hist['Close'].iloc[-2]) - 1) * 100,
                "ohlcv_5m": hist.tail(50).to_dict('records'),  # Последние 50 свечей
                "timestamp": datetime.now(timezone.utc).isoformat()
            }
        
        # Кэширование в Redis на 30 секунд
        self.redis_client.setex(
            "market_data", 
            30, 
            json.dumps(data, default=str)
        )
        
        return data
    
    def get_cached_data(self) -> Optional[Dict]:
        """Получение кэшированных данных"""
        cached = self.redis_client.get("market_data")
        if cached:
            return json.loads(cached)
        return None
```

### 2.3 SMT Analysis Engine Specification

```python
import pandas as pd
import numpy as np
from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime, time
import pytz

@dataclass
class SMTSignal:
    timestamp: datetime
    signal_type: str
    strength: float  # 0-1
    nasdaq_price: float
    sp500_price: float
    divergence_percentage: float
    confirmation_status: bool

@dataclass 
class OrderBlock:
    symbol: str
    timeframe: str
    high: float
    low: float
    timestamp: datetime
    block_type: str  # "bullish_ob" or "bearish_ob"
    strength: str   # "high", "medium", "low"

class SMTAnalyzer:
    def __init__(self):
        self.killzone_manager = KillzoneManager()
    
    def analyze_smt_divergence(self, nasdaq_data: pd.DataFrame, sp500_data: pd.DataFrame) -> List[SMTSignal]:
        """
        Анализ SMT дивергенции между NASDAQ и S&P500
        
        Логика:
        1. Сравнение momentum между инструментами
        2. Выявление расхождений в структуре рынка
        3. Подтверждение сигналов в активных killzone
        """
        signals = []
        
        # Вычисление относительной силы
        nasdaq_momentum = self._calculate_momentum(nasdaq_data, period=14)
        sp500_momentum = self._calculate_momentum(sp500_data, period=14)
        
        # Поиск дивергенций
        for i in range(len(nasdaq_momentum) - 1):
            if self._is_significant_divergence(nasdaq_momentum[i], sp500_momentum[i]):
                # Определение типа дивергенции
                if nasdaq_momentum[i] > sp500_momentum[i] + 0.5:  # NASDAQ сильнее
                    signal_type = "bullish_divergence"
                elif sp500_momentum[i] > nasdaq_momentum[i] + 0.5:  # S&P500 сильнее
                    signal_type = "bearish_divergence"
                else:
                    continue
                
                # Проверка активной killzone
                current_killzone = self.killzone_manager.get_active_killzone()
                if current_killzone in ["ny_am", "london"]:  # Приоритетные сессии
                    
                    signal = SMTSignal(
                        timestamp=nasdaq_data.index[i],
                        signal_type=signal_type,
                        strength=self._calculate_signal_strength(nasdaq_momentum[i], sp500_momentum[i]),
                        nasdaq_price=nasdaq_data['Close'].iloc[i],
                        sp500_price=sp500_data['Close'].iloc[i],
                        divergence_percentage=abs(nasdaq_momentum[i] - sp500_momentum[i]),
                        confirmation_status=self._confirm_signal(nasdaq_data.iloc[i-5:i+1], sp500_data.iloc[i-5:i+1])
                    )
                    signals.append(signal)
        
        return signals
    
    def detect_market_structure_shift(self, data: pd.DataFrame) -> List[Dict]:
        """Выявление Market Structure Shift (MSS)"""
        mss_events = []
        
        # Определение swing highs и lows
        highs = self._find_swing_points(data['High'], order=5)
        lows = self._find_swing_points(data['Low'], order=5, find_peaks=False)
        
        # Поиск нарушений структуры
        for i in range(1, len(highs)):
            # BOS (Break of Structure) для восходящего тренда
            if highs[i] > highs[i-1] and lows[i] > lows[i-1]:
                mss_events.append({
                    "type": "bullish_mss",
                    "timestamp": data.index[i],
                    "level": highs[i-1],
                    "confirmation_candle": data.iloc[i].to_dict()
                })
        
        return mss_events
    
    def identify_order_blocks(self, data: pd.DataFrame, timeframe: str = "15m") -> List[OrderBlock]:
        """Определение Order Blocks"""
        order_blocks = []
        
        # Поиск импульсных движений (сильные свечи с большим объемом)
        data['body_size'] = abs(data['Close'] - data['Open'])
        data['is_impulse'] = (data['body_size'] > data['body_size'].rolling(10).mean() * 1.5) & \
                            (data['Volume'] > data['Volume'].rolling(10).mean() * 1.2)
        
        impulse_candles = data[data['is_impulse']]
        
        for idx, candle in impulse_candles.iterrows():
            # Определение предыдущей консолидации как потенциального OB
            prev_data = data.loc[:idx].tail(10)
            
            if len(prev_data) >= 5:
                consolidation_high = prev_data['High'].max()
                consolidation_low = prev_data['Low'].min()
                
                # OB должен находиться перед импульсом
                if candle['Close'] > candle['Open']:  # Bullish impulse
                    ob_type = "bullish_ob"
                else:  # Bearish impulse
                    ob_type = "bearish_ob"
                
                order_block = OrderBlock(
                    symbol=data.attrs.get('symbol', 'UNKNOWN'),
                    timeframe=timeframe,
                    high=consolidation_high,
                    low=consolidation_low,
                    timestamp=idx,
                    block_type=ob_type,
                    strength=self._calculate_ob_strength(prev_data, candle)
                )
                order_blocks.append(order_block)
        
        return order_blocks
    
    def find_fair_value_gaps(self, data: pd.DataFrame) -> List[Dict]:
        """Поиск Fair Value Gaps (FVG)"""
        fvgs = []
        
        for i in range(2, len(data)):
            # FVG = gap между свечами, который не был заполнен
            candle_1 = data.iloc[i-2]  # Первая свеча
            candle_2 = data.iloc[i-1]  # Средняя свеча  
            candle_3 = data.iloc[i]    # Третья свеча
            
            # Bullish FVG: gap между low candle_3 и high candle_1
            if candle_3['Low'] > candle_1['High']:
                fvgs.append({
                    "type": "bullish_fvg",
                    "top": candle_3['Low'],
                    "bottom": candle_1['High'],
                    "timestamp": data.index[i],
                    "timeframe": data.attrs.get('timeframe', '5m'),
                    "filled_percentage": 0.0
                })
            
            # Bearish FVG: gap между high candle_3 и low candle_1  
            elif candle_3['High'] < candle_1['Low']:
                fvgs.append({
                    "type": "bearish_fvg", 
                    "top": candle_1['Low'],
                    "bottom": candle_3['High'],
                    "timestamp": data.index[i],
                    "timeframe": data.attrs.get('timeframe', '5m'),
                    "filled_percentage": 0.0
                })
        
        return fvgs

class KillzoneManager:
    KILLZONES = {
        'asia': {'start': time(20, 0), 'end': time(23, 59), 'timezone': 'UTC'},
        'london': {'start': time(2, 0), 'end': time(5, 0), 'timezone': 'UTC'}, 
        'ny_am': {'start': time(14, 30), 'end': time(16, 0), 'timezone': 'UTC'},  # 9:30-11:00 EST
        'ny_lunch': {'start': time(17, 0), 'end': time(18, 0), 'timezone': 'UTC'}, # 12:00-13:00 EST
        'ny_pm': {'start': time(18, 30), 'end': time(21, 0), 'timezone': 'UTC'}   # 13:30-16:00 EST
    }
    
    def get_active_killzone(self) -> Optional[str]:
        """Определение активной killzone"""
        current_time = datetime.now(pytz.UTC).time()
        
        for zone_name, zone_config in self.KILLZONES.items():
            if zone_config['start'] <= current_time <= zone_config['end']:
                return zone_name
        
        return None
    
    def is_high_priority_session(self) -> bool:
        """Проверка приоритетных торговых сессий"""
        active_zone = self.get_active_killzone()
        return active_zone in ['london', 'ny_am']
```

### 2.4 Claude Sonnet 4 Integration Specification

```python
import anthropic
import json
from typing import Dict, Any, Optional
from datetime import datetime
import asyncio
from dataclasses import asdict

class ClaudeAnalysisService:
    def __init__(self, api_key: str):
        self.client = anthropic.Anthropic(api_key=api_key)
        self.model = "claude-3-sonnet-20240229"
        self.max_tokens = 2000
        
    async def analyze_market_situation(self, market_context: Dict) -> Dict:
        """
        Отправка данных в Claude Sonnet 4 для анализа
        """
        
        system_prompt = self._get_system_prompt()
        user_message = self._prepare_market_data(market_context)
        
        try:
            response = await asyncio.to_thread(
                self.client.messages.create,
                model=self.model,
                max_tokens=self.max_tokens,
                system=system_prompt,
                messages=[{
                    "role": "user", 
                    "content": user_message
                }]
            )
            
            # Парсинг JSON ответа
            analysis_result = json.loads(response.content[0].text)
            
            # Валидация структуры ответа
            validated_result = self._validate_response(analysis_result)
            
            return validated_result
            
        except Exception as e:
            return self._generate_fallback_analysis(market_context, str(e))
    
    def _get_system_prompt(self) -> str:
        return """
        Вы — эксперт по анализу рынка с использованием Smart Money Theory (SMT). 
        Специализируетесь на корреляционном анализе NASDAQ (QQQ) и S&P500 (SPY).

        ВАШИ ЗАДАЧИ:
        1. Анализировать SMT дивергенции во время активных killzones
        2. Интерпретировать Market Structure Shifts (MSS) и Change in State of Delivery (CISD)
        3. Оценивать Order Blocks и Fair Value Gaps
        4. Предоставлять структурированные торговые рекомендации

        KILLZONES (UTC):
        - Asia: 20:00-00:00
        - London: 02:00-05:00  
        - NY AM: 14:30-16:00 (приоритетная)
        - NY Lunch: 17:00-18:00
        - NY PM: 18:30-21:00

        ФОРМАТ ОТВЕТА: Только валидный JSON в указанной структуре.
        
        ТОРГОВАЯ ФИЛОСОФИЯ SMT:
        - Институциональные игроки создают ликвидность для своих позиций
        - Sweeps ликвидности часто предшествуют сильным движениям
        - Дивергенции между индексами показывают умные деньги
        - Structure breaks подтверждают изменение настроений
        """
    
    def _prepare_market_data(self, context: Dict) -> str:
        """Форматирование данных для отправки в Claude"""
        
        prompt = f"""
        Проанализируйте текущую рыночную ситуацию:

        ВРЕМЯ И СЕССИЯ:
        - Timestamp: {context.get('timestamp')}
        - Активная Killzone: {context.get('killzone', {}).get('current')}
        - Осталось времени в сессии: {context.get('killzone', {}).get('time_remaining')}

        РЫНОЧНЫЕ ДАННЫЕ:
        NASDAQ (QQQ): ${context.get('market_data', {}).get('nasdaq', {}).get('current_price')}
        - Изменение: {context.get('market_data', {}).get('nasdaq', {}).get('change_percent')}%
        - Объем: {context.get('market_data', {}).get('nasdaq', {}).get('volume'):,}
        - 5m тренд: {context.get('market_data', {}).get('nasdaq', {}).get('timeframes', {}).get('5m', {}).get('trend')}
        - RSI 5m: {context.get('market_data', {}).get('nasdaq', {}).get('timeframes', {}).get('5m', {}).get('rsi')}

        S&P500 (SPY): ${context.get('market_data', {}).get('sp500', {}).get('current_price')}
        - Изменение: {context.get('market_data', {}).get('sp500', {}).get('change_percent')}%
        - Объем: {context.get('market_data', {}).get('sp500', {}).get('volume'):,}
        - 5m тренд: {context.get('market_data', {}).get('sp500', {}).get('timeframes', {}).get('5m', {}).get('trend')}
        - RSI 5m: {context.get('market_data', {}).get('sp500', {}).get('timeframes', {}).get('5m', {}).get('rsi')}

        SMT СИГНАЛЫ: {json.dumps(context.get('smt_signals', []), indent=2)}

        СТРУКТУРА РЫНКА: {json.dumps(context.get('market_structure', {}), indent=2)}

        МАКРО КОНТЕКСТ:
        - VIX: {context.get('macro_context', {}).get('vix')}
        - DXY: {context.get('macro_context', {}).get('dxy')}
        - События: {context.get('macro_context', {}).get('economic_events', [])}

        Предоставьте анализ в следующем JSON формате:
        {{
            "analysis_id": "string",
            "timestamp": "ISO datetime",
            "market_bias": "bullish|bearish|neutral",
            "confidence_score": 0-100,
            "risk_level": "low|medium|high",
            "key_insights": ["insight1", "insight2", "insight3"],
            "technical_analysis": {{
                "smt_interpretation": "detailed analysis",
                "market_structure_analysis": "MSS/CISD analysis", 
                "killzone_impact": "session impact analysis"
            }},
            "trading_recommendation": {{
                "bias": "bullish|bearish|neutral",
                "entry_zone": "price range",
                "target_levels": ["level1", "level2"],
                "stop_loss": "price level",
                "risk_reward": number,
                "position_size_suggestion": "conservative|moderate|aggressive"
            }},
            "risk_factors": ["factor1", "factor2"],
            "probability_assessment": {{
                "scenario_bullish": percentage,
                "scenario_neutral": percentage,
                "scenario_bearish": percentage
            }},
            "next_monitoring_points": ["point1", "point2"]
        }}
        """
        
        return prompt
    
    def _validate_response(self, response: Dict) -> Dict:
        """Валидация структуры ответа от Claude"""
        required_fields = [
            'market_bias', 'confidence_score', 'technical_analysis',
            'trading_recommendation', 'risk_factors'
        ]
        
        for field in required_fields:
            if field not in response:
                raise ValueError(f"Missing required field: {field}")
        
        # Проверка диапазонов
        if not 0 <= response['confidence_score'] <= 100:
            response['confidence_score'] = max(0, min(100, response['confidence_score']))
        
        # Добавление timestamp если отсутствует
        if 'timestamp' not in response:
            response['timestamp'] = datetime.now().isoformat()
        
        return response
    
    def _generate_fallback_analysis(self, context: Dict, error: str) -> Dict:
        """Fallback анализ при ошибке Claude API"""
        return {
            "analysis_id": f"fallback_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
            "timestamp": datetime.now().isoformat(),
            "market_bias": "neutral",
            "confidence_score": 30,
            "risk_level": "high",
            "key_insights": [
                "LLM анализ временно недоступен",
                "Используется базовый технический анализ",
                "Рекомендуется дождаться восстановления сервиса"
            ],
            "technical_analysis": {
                "smt_interpretation": f"Анализ недоступен из-за ошибки: {error}",
                "market_structure_analysis": "Требуется ручной анализ",
                "killzone_impact": "Не определено"
            },
            "trading_recommendation": {
                "bias": "neutral",
                "entry_zone": "Не рекомендуется",
                "target_levels": [],
                "stop_loss": "N/A",
                "risk_reward": 0,
                "position_size_suggestion": "conservative"
            },
            "risk_factors": [
                "LLM сервис недоступен",
                "Анализ может быть неточным"
            ],
            "probability_assessment": {
                "scenario_bullish": 33,
                "scenario_neutral": 34,
                "scenario_bearish": 33
            },
            "next_monitoring_points": [
                "Дождаться восстановления LLM сервиса",
                "Провести ручной анализ"
            ]
        }
```

### 2.5 Frontend Requirements

```typescript
// TypeScript интерфейсы для фронтенда
interface MarketData {
  symbol: string;
  currentPrice: number;
  changePercent: number;
  volume: number;
  timestamp: string;
  ohlcv5m: OHLCV[];
}

interface OHLCV {
  timestamp: string;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
}

interface SMTSignal {
  id: string;
  timestamp: string;
  type: 'bullish_divergence' | 'bearish_divergence';
  strength: number;
  confirmationStatus: boolean;
  liquiditySweep?: {
    detected: boolean;
    sweepType: 'buy_side' | 'sell_side';
    level: number;
  };
}

interface AnalysisResult {
  analysisId: string;
  timestamp: string;
  marketBias: 'bullish' | 'bearish' | 'neutral';
  confidenceScore: number;
  riskLevel: 'low' | 'medium' | 'high';
  keyInsights: string[];
  technicalAnalysis: {
    smtInterpretation: string;
    marketStructureAnalysis: string;
    killzoneImpact: string;
  };
  tradingRecommendation: {
    bias: string;
    entryZone: string;
    targetLevels: string[];
    stopLoss: string;
    riskReward: number;
    positionSizeSuggestion: string;
  };
  riskFactors: string[];
  probabilityAssessment: {
    scenarioBullish: number;
    scenarioNeutral: number;
    scenarioBearish: number;
  };
}

// React компоненты
const TradingDashboard: React.FC = () => {
  const [marketData, setMarketData] = useState<MarketData[]>([]);
  const [smtSignals, setSmtSignals] = useState<SMTSignal[]>([]);
  const [analysis, setAnalysis] = useState<AnalysisResult | null>(null);
  const [activeKillzone, setActiveKillzone] = useState<string>('');

  // WebSocket подключение для real-time данных
  useEffect(() => {
    const ws = new WebSocket('ws://localhost:8000/ws/market-updates');
    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      setMarketData(data.marketData);
      setSmtSignals(data.smtSignals);
      setAnalysis(data.analysis);
      setActiveKillzone(data.activeKillzone);
    };
    return () => ws.close();
  }, []);
};
```

## 3. Deployment Configuration

### 3.1 Docker Compose Setup

```yaml
version: '3.8'

services:
  backend:
    build: 
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=sqlite:///./smt_trading.db
      - REDIS_URL=redis://redis:6379
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
    depends_on:
      - redis
    volumes:
      - ./backend:/app
      - ./data:/app/data

  frontend:
    build:
      context: ./frontend  
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - REACT_APP_API_URL=http://localhost:8000
    volumes:
      - ./frontend:/app
      - /app/node_modules

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  celery:
    build:
      context: ./backend
      dockerfile: Dockerfile
    command: celery -A app.tasks.celery_app worker --loglevel=info
    environment:
      - DATABASE_URL=sqlite:///./smt_trading.db
      - REDIS_URL=redis://redis:6379
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
    depends_on:
      - redis
    volumes:
      - ./backend:/app

volumes:
  redis_data:
```

## 4. Готовность к разработке

Все спецификации готовы для реализации с Claude Sonnet 4:

✅ **Четко определенная архитектура**
✅ **Детальные технические требования** 
✅ **Готовые к реализации модули**
✅ **Структурированный код с типизацией**
✅ **Docker конфигурация для развертывания**
✅ **Integration с Claude Sonnet 4**

**Следующий шаг**: Начать реализацию с Backend Core Infrastructure.

Готов приступить к написанию кода?